<!DOCTYPE html>
<html>

<head>
    <title>Segmentation Task</title>
    <meta charset="UTF-8" />

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            /* Prevent full page scroll when drawing */
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Toolbar Styling */
        .toolbar {
            margin-bottom: 10px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            flex-shrink: 0;
            /* Don't shrink toolbar */
        }

        .tool-group {
            display: inline-block;
            margin-right: 20px;
            border-right: 1px solid #ccc;
            padding-right: 20px;
        }

        /* 
           CONTAINER FOR ZOOMING 
           This box stays the same size on screen, but handles scrollbars 
        */
        #canvasContainer {
            flex-grow: 1;
            /* Fill remaining height */
            overflow: auto;
            /* Show scrollbars if zoomed */
            border: 2px solid #999;
            background-color: #333;
            /* Dark background for easier viewing */
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* The wrapper that actually gets resized by CSS */
        #canvasWrapper {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        canvas {
            display: block;
            /* Important: Width/Height controlled by JS for Zoom */
        }
    </style>
</head>

<body>

    <div class="toolbar">
        <!-- TOOLS -->
        <div class="tool-group">
            <button onclick="setTool('brush')">üñå Brush (B)</button>
            <button onclick="setTool('eraser')">üßΩ Eraser (E)</button>
            <button onclick="setTool('pencil')">‚úèÔ∏è Pencil (P)</button>
            <button onclick="setTool('rect')">‚¨õ Rect (R)</button>
            <button onclick="setTool('circle')">‚ö™ Circle (C)</button>
            <button onclick="setTool('polygon')">üî∫ Polygon (G)</button>
        </div>

        <!-- ACTIONS -->
        <div class="tool-group">
            <button onclick="undo()">‚Ü© Undo (Z)</button>
            <button onclick="redo()">‚Ü™ Redo (Y)</button>
            <button onclick="saveMask()">üíæ Save (S)</button>
        </div>

        <!-- ZOOM & OPACITY -->
        <div class="tool-group">
            <strong>Zoom:</strong>
            <button onclick="changeZoom(0.1)">‚ûï</button>
            <button onclick="changeZoom(-0.1)">‚ûñ</button>
            <button onclick="resetZoom()">Fit</button>
            <span id="zoomDisplay">100%</span>
        </div>

        <div>
            Opacity: <input type="range" min="0.0" max="1.0" step="0.1" value="0.5" oninput="setMaskOpacity(this.value)"
                style="vertical-align: middle;">
            &nbsp;|&nbsp;
            Brush: <input type="range" min="1" max="50" value="10" oninput="brushSize=this.value"
                style="vertical-align: middle;">
        </div>

        <div style="margin-top:5px; font-size: 0.85em; color: #666;">
            Task: <span id="taskId">...</span> | Image: <span id="imageName">...</span>
        </div>
    </div>

    <!-- MAIN WORKSPACE -->
    <div id="canvasContainer">
        <div id="canvasWrapper">
            <canvas id="imageCanvas"></canvas>
            <canvas id="maskCanvas" style="position:absolute; left:0; top:0; opacity: 0.5;"></canvas>
        </div>
    </div>

    <script>
        /* ------------------------------
           BASIC SETUP
        ------------------------------ */
        const parts = window.location.pathname.split("/").filter(Boolean);
        const taskId = parts[parts.length - 1];

        const canvasWrapper = document.getElementById("canvasWrapper");
        const imageCanvas = document.getElementById("imageCanvas");
        const maskCanvas = document.getElementById("maskCanvas");

        const imgCtx = imageCanvas.getContext("2d");
        const maskCtx = maskCanvas.getContext("2d", { willReadFrequently: true });

        // Set solid color (opacity handled by CSS/Layer)
        maskCtx.fillStyle = "rgb(0, 100, 255)";

        // State
        let currentZoom = 1.0;
        let originalWidth = 0;
        let originalHeight = 0;

        /* ------------------------------
           ZOOM LOGIC
        ------------------------------ */
        function changeZoom(delta) {
            const newZoom = Math.max(0.1, Math.min(5.0, currentZoom + delta)); // Limit 10% to 500%
            applyZoom(newZoom);
        }

        function resetZoom() {
            applyZoom(1.0);
        }

        function applyZoom(zoomLevel) {
            currentZoom = zoomLevel;
            document.getElementById("zoomDisplay").innerText = Math.round(currentZoom * 100) + "%";

            // We calculate the CSS width/height based on the original image dimensions
            const cssWidth = originalWidth * currentZoom;
            const cssHeight = originalHeight * currentZoom;

            // Apply visual size to canvases
            imageCanvas.style.width = cssWidth + "px";
            imageCanvas.style.height = cssHeight + "px";
            maskCanvas.style.width = cssWidth + "px";
            maskCanvas.style.height = cssHeight + "px";

            // Adjust wrapper to match
            canvasWrapper.style.width = cssWidth + "px";
            canvasWrapper.style.height = cssHeight + "px";
        }

        // Mouse Wheel Zoom Support (Ctrl + Scroll)
        document.getElementById("canvasContainer").addEventListener("wheel", function (e) {
            if (e.ctrlKey) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                changeZoom(delta);
            }
        });

        /* ------------------------------
           COORDINATE TRANSLATION (CRITICAL)
        ------------------------------ */
        function getMousePos(e) {
            const rect = maskCanvas.getBoundingClientRect();

            // Calculate scale ratio (Internal Resolution / Visual Size)
            const scaleX = maskCanvas.width / rect.width;
            const scaleY = maskCanvas.height / rect.height;

            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        /* ------------------------------
           TOOL STATE & HANDLERS
        ------------------------------ */
        const tools = { BRUSH: "brush", ERASER: "eraser", PENCIL: "pencil", RECT: "rect", CIRCLE: "circle", POLYGON: "polygon" };
        let currentTool = tools.BRUSH;
        let brushSize = 10;
        let isDrawing = false;
        let startX = 0, startY = 0;
        let polygonPoints = [];
        let polygonPreviewImage = null;
        let isShiftPressed = false;
        const SNAP_DISTANCE = 10;

        /* ------------------------------
           MOUSE EVENTS
        ------------------------------ */
        maskCanvas.addEventListener("mousedown", e => {
            const pos = getMousePos(e);
            startX = pos.x;
            startY = pos.y;

            if (currentTool === tools.POLYGON) {
                handlePolygonClick(startX, startY);
                return;
            }
            isDrawing = true;
            saveState();
        });

        maskCanvas.addEventListener("mousemove", e => {
            const pos = getMousePos(e);
            const mouseX = pos.x;
            const mouseY = pos.y;

            // Polygon Preview
            if (currentTool === tools.POLYGON && polygonPoints.length > 0) {
                drawPolygonPreview(mouseX, mouseY);
                return;
            }

            if (!isDrawing) return;

            // Drawing Tools
            if (currentTool === tools.BRUSH) drawBrush(mouseX, mouseY);
            else if (currentTool === tools.ERASER) erase(mouseX, mouseY);
            else if (currentTool === tools.PENCIL) drawPixel(mouseX, mouseY);
        });

        maskCanvas.addEventListener("mouseup", e => {
            isDrawing = false;
            const pos = getMousePos(e);

            if (currentTool === tools.RECT) drawRect(startX, startY, pos.x, pos.y);
            if (currentTool === tools.CIRCLE) drawCircle(startX, startY, pos.x, pos.y);
        });

        /* ------------------------------
           DRAWING FUNCTIONS
        ------------------------------ */
        function drawBrush(x, y) {
            maskCtx.beginPath();
            maskCtx.arc(x, y, brushSize, 0, Math.PI * 2);
            maskCtx.fill();
        }

        function erase(x, y) {
            maskCtx.globalCompositeOperation = "destination-out";
            maskCtx.beginPath();
            maskCtx.arc(x, y, brushSize, 0, Math.PI * 2);
            maskCtx.fill();
            maskCtx.globalCompositeOperation = "source-over";
        }

        function drawPixel(x, y) {
            maskCtx.fillRect(Math.floor(x), Math.floor(y), 1, 1);
        }

        function drawRect(x1, y1, x2, y2) {
            maskCtx.fillRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));
        }

        function drawCircle(x1, y1, x2, y2) {
            const cx = (x1 + x2) / 2;
            const cy = (y1 + y2) / 2;
            const rx = Math.abs(x2 - x1) / 2;
            const ry = Math.abs(y2 - y1) / 2;
            maskCtx.beginPath();
            maskCtx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
            maskCtx.fill();
        }

        /* ------------------------------
           POLYGON LOGIC
        ------------------------------ */
        function handlePolygonClick(px, py) {
            if (polygonPoints.length === 0) {
                saveState();
                polygonPreviewImage = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
            }

            // Snap logic
            if (polygonPoints.length > 0) {
                const first = polygonPoints[0];
                if (Math.hypot(px - first.x, py - first.y) < SNAP_DISTANCE && polygonPoints.length >= 3) {
                    px = first.x; py = first.y; // Snap to start
                }
            }
            polygonPoints.push({ x: px, y: py });
        }

        function drawPolygonPreview(currX, currY) {
            // Restore clean state
            maskCtx.putImageData(polygonPreviewImage, 0, 0);

            const first = polygonPoints[0];
            const last = polygonPoints[polygonPoints.length - 1];

            // Shift Lock (Straight lines)
            if (isShiftPressed) {
                if (Math.abs(currX - last.x) > Math.abs(currY - last.y)) currY = last.y;
                else currX = last.x;
            }

            // Draw current path
            maskCtx.beginPath();
            maskCtx.moveTo(first.x, first.y);
            polygonPoints.forEach(p => maskCtx.lineTo(p.x, p.y));
            maskCtx.lineTo(currX, currY);

            // Style for preview
            maskCtx.lineWidth = 2;
            maskCtx.strokeStyle = "rgba(0,0,0,0.8)"; // Black line for visibility
            maskCtx.stroke();

            // Draw lines again in white for contrast (optional)
            maskCtx.strokeStyle = "white";
            maskCtx.lineWidth = 1;
            maskCtx.stroke();

            // Reset
            maskCtx.lineWidth = 1;
            maskCtx.fillStyle = "rgb(0, 100, 255)"; // Reset fill color
        }

        // Close polygon on Double Click or Enter
        maskCanvas.addEventListener("dblclick", () => finishPolygon());

        function finishPolygon() {
            if (polygonPoints.length < 3) return;
            maskCtx.putImageData(polygonPreviewImage, 0, 0); // Clear preview lines
            maskCtx.beginPath();
            maskCtx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
            polygonPoints.forEach(p => maskCtx.lineTo(p.x, p.y));
            maskCtx.closePath();
            maskCtx.fill(); // Fill with the solid blue
            polygonPoints = [];
            polygonPreviewImage = null;
        }

        /* ------------------------------
           UNDO / REDO / SAVE
        ------------------------------ */
        const undoStack = [];
        const redoStack = [];

        function saveState() {
            undoStack.push(maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height));
            if (undoStack.length > 30) undoStack.shift();
            redoStack.length = 0;
        }

        function undo() {
            if (!undoStack.length) return;
            redoStack.push(maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height));
            maskCtx.putImageData(undoStack.pop(), 0, 0);
        }

        function redo() {
            if (!redoStack.length) return;
            undoStack.push(maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height));
            maskCtx.putImageData(redoStack.pop(), 0, 0);
        }

        function saveMask() {
            const dataUrl = maskCanvas.toDataURL("image/png");
            fetch(`/api/segmenter/task/${taskId}/save-mask/`, {
                method: "POST",
                headers: { "Content-Type": "application/json", "X-CSRFToken": getCSRFToken() },
                body: JSON.stringify({ mask: dataUrl })
            }).then(() => alert("Saved!")).catch(() => alert("Failed!"));
        }

        function getCSRFToken() {
            return document.cookie.split("; ").find(row => row.startsWith("csrftoken"))?.split("=")[1];
        }

        /* ------------------------------
           UTILITIES
        ------------------------------ */
        function setTool(t) { currentTool = t; polygonPoints = []; }
        function setMaskOpacity(val) { maskCanvas.style.opacity = val; }

        document.addEventListener("keydown", e => {
            if (e.target.tagName === "INPUT") return;
            if (e.key === "b") setTool(tools.BRUSH);
            if (e.key === "e") setTool(tools.ERASER);
            if (e.key === "z") undo();
            if (e.key === "Shift") isShiftPressed = true;
            if (e.key === "Enter" && currentTool === tools.POLYGON) finishPolygon();
            if (e.key === "Escape" && currentTool === tools.POLYGON) {
                maskCtx.putImageData(polygonPreviewImage, 0, 0);
                polygonPoints = [];
            }
        });
        document.addEventListener("keyup", e => { if (e.key === "Shift") isShiftPressed = false; });


        /* ------------------------------
           INIT
        ------------------------------ */
        fetch(`/api/segmenter/task/${taskId}/`)
            .then(res => res.json())
            .then(task => {
                document.getElementById("taskId").innerText = task.task_id;
                document.getElementById("imageName").innerText = task.image_name;

                const img = new Image();
                img.src = task.image_path;
                img.onload = () => {
                    // Set Internal Resolution
                    originalWidth = img.width;
                    originalHeight = img.height;

                    imageCanvas.width = originalWidth;
                    imageCanvas.height = originalHeight;
                    maskCanvas.width = originalWidth;
                    maskCanvas.height = originalHeight;

                    // Draw image
                    imgCtx.drawImage(img, 0, 0);

                    // Initialize View
                    applyZoom(1.0);
                    loadAIMask();
                };
            });

        function loadAIMask() {
            fetch(`/api/ai/presegment/${taskId}/`)
                .then(res => res.json())
                .then(data => {
                    if (!data.mask) return;
                    const m = new Image();
                    m.src = data.mask;
                    m.onload = () => maskCtx.drawImage(m, 0, 0);
                });
        }
    </script>
</body>

</html>