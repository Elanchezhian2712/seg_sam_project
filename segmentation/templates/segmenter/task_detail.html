{% load static %}

<!DOCTYPE html>
<html>

<head>
    <title>Segmentation Task</title>
    <meta charset="UTF-8" />
    <!-- Fabric.js Library -->
    <script src="{% static 'js/fabric.min.js' %}"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            margin-bottom: 10px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            flex-shrink: 0;
        }

        .tool-group {
            display: inline-block;
            margin-right: 20px;
            border-right: 1px solid #ccc;
            padding-right: 20px;
        }

        .tool-group:last-child {
            border-right: none;
        }

        button {
            padding: 5px 10px;
            margin: 2px;
            cursor: pointer;
        }

        button.active {
            background-color: #4CAF50;
            color: white;
        }

        #canvasContainer {
            flex-grow: 1;
            overflow: auto;
            border: 2px solid #999;
            background-color: #333;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #canvasWrapper {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            display: inline-block;
        }

        #imageCanvas {
            display: block;
        }

        #fabricCanvas {
            position: absolute;
            left: 0;
            top: 0;
        }

        .canvas-container {
            position: absolute !important;
            left: 0 !important;
            top: 0 !important;
        }
    </style>
</head>

<body>

    <div class="toolbar">
        <!-- TOOLS -->
        <div class="tool-group">
            <button id="btn-select" onclick="setTool('select')">üëÜ Select (V)</button>
            <button id="btn-brush" onclick="setTool('brush')">üñå Brush (B)</button>
            <button id="btn-eraser" onclick="setTool('eraser')">üßΩ Eraser (E)</button>
            <button id="btn-pencil" onclick="setTool('pencil')">‚úèÔ∏è Pencil (P)</button>
            <button id="btn-rect" onclick="setTool('rect')">‚¨õ Rect (R)</button>
            <button id="btn-circle" onclick="setTool('circle')">‚ö™ Circle (C)</button>
            <button id="btn-polygon" onclick="setTool('polygon')">üî∫ Polygon (G)</button>
        </div>

        <!-- ACTIONS -->
        <div class="tool-group">
            <button onclick="deleteSelected()" id="btn-delete">üóëÔ∏è Delete (Del)</button>
            <button onclick="undo()">‚Ü© Undo (Z)</button>
            <button onclick="redo()">‚Ü™ Redo (Y)</button>
            <button onclick="saveMask()">üíæ Save (S)</button>
            <button onclick="submitTask()" style="background-color: #4CAF50; color: white;">‚úÖ Submit Task</button>
        </div>

        <!-- ZOOM & OPACITY -->
        <div class="tool-group">
            <strong>Zoom:</strong>
            <button onclick="changeZoom(0.1)">‚ûï</button>
            <button onclick="changeZoom(-0.1)">‚ûñ</button>
            <button onclick="resetZoom()">Fit</button>
            <span id="zoomDisplay">100%</span>
        </div>

        <div>
            Opacity: <input type="range" min="0.0" max="1.0" step="0.1" value="0.5" id="opacitySlider"
                oninput="setMaskOpacity(this.value)" style="vertical-align: middle;">
            &nbsp;|&nbsp;
            Brush: <input type="range" min="1" max="50" value="10" id="brushSlider" oninput="setBrushSize(this.value)"
                style="vertical-align: middle;">
            <span id="brushSizeDisplay">10px</span>
        </div>

        <div style="margin-top:5px; font-size: 0.85em; color: #666;">
            Task: <span id="taskId">...</span> | Image: <span id="imageName">...</span>
        </div>
    </div>

    <!-- MAIN WORKSPACE -->
    <div id="canvasContainer">
        <div id="canvasWrapper">
            <canvas id="imageCanvas"></canvas>
            <canvas id="fabricCanvas"></canvas>
        </div>
    </div>

    <script>
        /* ------------------------------
           BASIC SETUP
        ------------------------------ */
        const parts = window.location.pathname.split("/").filter(Boolean);
        const taskId = parts[parts.length - 1];

        const imageCanvas = document.getElementById("imageCanvas");
        const imgCtx = imageCanvas.getContext("2d");

        const canvas = new fabric.Canvas('fabricCanvas', {
            isDrawingMode: false,
            selection: true,
            backgroundColor: 'transparent',
            preserveObjectStacking: true
        });

        canvas.on('mouse:down', function (e) {
            const pointer = canvas.getPointer(e.e);
            const objects = canvas.getObjects();
            objects.forEach((obj, i) => {
                if (obj.type !== 'image') {
                    console.log(`  Object ${i} (${obj.type}):`, {
                        left: obj.left,
                        top: obj.top,
                        width: obj.width || (obj.rx * 2),
                        height: obj.height || (obj.ry * 2),
                        selectable: obj.selectable,
                        evented: obj.evented,
                        visible: obj.visible,
                        opacity: obj.opacity
                    });

                    // Manual bounds check
                    const right = obj.left + (obj.width || obj.rx * 2);
                    const bottom = obj.top + (obj.height || obj.ry * 2);
                    const inside = pointer.x >= obj.left && pointer.x <= right &&
                        pointer.y >= obj.top && pointer.y <= bottom;
                }
            });
        });

        /* ------------------------------
           STATE MANAGEMENT
        ------------------------------ */
        const tools = {
            SELECT: "select",
            BRUSH: "brush",
            ERASER: "eraser",
            PENCIL: "pencil",
            RECT: "rect",
            CIRCLE: "circle",
            POLYGON: "polygon"
        };

        let currentTool = tools.BRUSH;
        let brushSize = 10;
        let maskOpacity = 0.5;
        let currentZoom = 1.0;
        let originalWidth = 0;
        let originalHeight = 0;

        // Undo/Redo stacks
        let historyStack = [];
        let redoStack = [];
        const MAX_HISTORY = 30;

        // Polygon state
        let polygonPoints = [];
        let polygonLineGroup = null;
        let isDrawingPolygon = false;

        // Shape drawing state
        let isDrawingShape = false;
        let shapeStartPoint = null;
        let currentShape = null;

        /* ------------------------------
           TOOL SELECTION - FIXED WITH LOGGING
        ------------------------------ */
        function setTool(tool) {

            currentTool = tool;

            document.querySelectorAll('.tool-group button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`btn-${tool}`)?.classList.add('active');

            if (tool !== tools.POLYGON) {
                clearPolygon();
            }

            // Deactivate drawing mode for all tools except brush/pencil/eraser
            canvas.isDrawingMode = (tool === tools.BRUSH || tool === tools.PENCIL || tool === tools.ERASER);

            if (tool === tools.SELECT) {
                canvas.selection = true;
                canvas.getObjects().forEach((obj, index) => {
                    const isEraserPath = obj.globalCompositeOperation === 'destination-out';
                    if (!isEraserPath && obj.type !== 'image') {
                        obj.selectable = true;
                        obj.evented = true;
                        obj.hasControls = true;
                        obj.hasBorders = true;
                        obj.lockMovementX = false;
                        obj.lockMovementY = false;
                    } else {
                        obj.selectable = false;
                        obj.evented = false;
                    }
                });

            } else if (tool === tools.BRUSH || tool === tools.PENCIL) {
                canvas.selection = false;
                canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                canvas.freeDrawingBrush.color = 'rgba(0, 100, 255, 0.8)';
                canvas.freeDrawingBrush.width = tool === tools.PENCIL ? 1 : brushSize;
                canvas.freeDrawingBrush.globalCompositeOperation = 'source-over';
                canvas.discardActiveObject();
                canvas.getObjects().forEach(obj => {
                    obj.selectable = false;
                    obj.evented = false;
                });
            } else if (tool === tools.ERASER) {
                canvas.selection = false;
                canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                canvas.freeDrawingBrush.width = brushSize;
                canvas.freeDrawingBrush.color = '#FFFFFF';
                canvas.freeDrawingBrush.globalCompositeOperation = 'destination-out';
                canvas.discardActiveObject();
                canvas.getObjects().forEach(obj => {
                    obj.selectable = false;
                    obj.evented = false;
                });
            } else {
                canvas.selection = false;
                canvas.discardActiveObject();
                canvas.getObjects().forEach(obj => {
                    obj.selectable = false;
                    obj.evented = false;
                });
            }

            canvas.renderAll();
        }

        /* ------------------------------
           BRUSH SIZE & OPACITY
        ------------------------------ */
        function setBrushSize(size) {
            brushSize = parseInt(size);
            document.getElementById('brushSizeDisplay').innerText = brushSize + 'px';

            if (canvas.freeDrawingBrush) {
                canvas.freeDrawingBrush.width = brushSize;
            }
        }

        function setMaskOpacity(value) {
            maskOpacity = parseFloat(value);
            canvas.getObjects().forEach(obj => {
                if (obj.type !== 'image') {
                    obj.set('opacity', maskOpacity);
                }
            });
            canvas.renderAll();
        }

        /* ------------------------------
           ZOOM FUNCTIONS
        ------------------------------ */
        function changeZoom(delta) {
            const newZoom = Math.max(0.1, Math.min(5.0, currentZoom + delta));
            applyZoom(newZoom);
        }

        function resetZoom() {
            applyZoom(1.0);
        }

        function applyZoom(zoomLevel) {
            currentZoom = zoomLevel;
            document.getElementById("zoomDisplay").innerText = Math.round(currentZoom * 100) + "%";

            const newWidth = originalWidth * currentZoom;
            const newHeight = originalHeight * currentZoom;

            canvas.setZoom(currentZoom);
            canvas.setWidth(newWidth);
            canvas.setHeight(newHeight);

            imageCanvas.style.width = newWidth + 'px';
            imageCanvas.style.height = newHeight + 'px';

            const canvasWrapper = document.getElementById('canvasWrapper');
            canvasWrapper.style.width = newWidth + 'px';
            canvasWrapper.style.height = newHeight + 'px';

            canvas.renderAll();
        }

        canvas.on('mouse:wheel', function (opt) {
            const delta = opt.e.deltaY;
            let zoom = canvas.getZoom();
            zoom *= 0.999 ** delta;

            if (zoom > 5) zoom = 5;
            if (zoom < 0.1) zoom = 0.1;

            applyZoom(zoom);

            opt.e.preventDefault();
            opt.e.stopPropagation();
        });

        /* ------------------------------
           SHAPE DRAWING (RECT, CIRCLE) 
        ------------------------------ */
        let shapeDrawingMouseDown, shapeDrawingMouseMove, shapeDrawingMouseUp;

        shapeDrawingMouseDown = function (options) {
            if (currentTool === tools.SELECT) {
                return;
            }

            if (currentTool === tools.POLYGON) {
                handlePolygonClick(options);
                return;
            }

            if (currentTool === tools.RECT || currentTool === tools.CIRCLE) {
                isDrawingShape = true;
                const pointer = canvas.getPointer(options.e);
                shapeStartPoint = pointer;

                saveState();

                if (currentTool === tools.RECT) {
                    currentShape = new fabric.Rect({
                        left: pointer.x,
                        top: pointer.y,
                        width: 0,
                        height: 0,
                        fill: 'rgba(0, 100, 255, 0.8)',
                        stroke: 'rgb(0, 100, 255)',
                        strokeWidth: 1,
                        selectable: false,
                        evented: false,
                        opacity: maskOpacity
                    });
                } else if (currentTool === tools.CIRCLE) {
                    currentShape = new fabric.Ellipse({
                        left: pointer.x,
                        top: pointer.y,
                        rx: 0,
                        ry: 0,
                        fill: 'rgba(0, 100, 255, 0.8)',
                        stroke: 'rgb(0, 100, 255)',
                        strokeWidth: 1,
                        selectable: false,
                        evented: false,
                        opacity: maskOpacity
                    });
                }

                canvas.add(currentShape);
                canvas.renderAll();
            }
        };

        shapeDrawingMouseMove = function (options) {
            // Don't interfere with selection in SELECT mode
            if (currentTool === tools.SELECT) {
                return;
            }

            if (!isDrawingShape || !currentShape) return;

            const pointer = canvas.getPointer(options.e);

            if (currentTool === tools.RECT) {
                const width = pointer.x - shapeStartPoint.x;
                const height = pointer.y - shapeStartPoint.y;

                currentShape.set({
                    width: Math.abs(width),
                    height: Math.abs(height),
                    left: width > 0 ? shapeStartPoint.x : pointer.x,
                    top: height > 0 ? shapeStartPoint.y : pointer.y
                });
            } else if (currentTool === tools.CIRCLE) {
                const rx = Math.abs(pointer.x - shapeStartPoint.x) / 2;
                const ry = Math.abs(pointer.y - shapeStartPoint.y) / 2;

                currentShape.set({
                    rx: rx,
                    ry: ry,
                    left: Math.min(pointer.x, shapeStartPoint.x),
                    top: Math.min(pointer.y, shapeStartPoint.y)
                });
            }

            canvas.renderAll();
        };

        shapeDrawingMouseUp = function (options) {
            if (currentTool === tools.SELECT) {
                return;
            }

            if (isDrawingShape && currentShape) {
                currentShape.set({
                    evented: true,
                    selectable: true,
                    hasControls: true,
                    hasBorders: true
                });

                isDrawingShape = false;
                const finishedShape = currentShape;
                currentShape = null;
                shapeStartPoint = null;

                canvas.renderAll();

                setTimeout(() => {
                    setTool(tools.SELECT);

                    canvas.setActiveObject(finishedShape);
                    canvas.renderAll();
                }, 10);
            }
        };

        canvas.on('mouse:down', shapeDrawingMouseDown);
        canvas.on('mouse:move', shapeDrawingMouseMove);
        canvas.on('mouse:up', shapeDrawingMouseUp);

        /* ------------------------------
           POLYGON TOOL
        ------------------------------ */
        function handlePolygonClick(options) {
            const pointer = canvas.getPointer(options.e);

            if (polygonPoints.length === 0) {
                saveState();
                isDrawingPolygon = true;
            }

            if (polygonPoints.length >= 3) {
                const firstPoint = polygonPoints[0];
                const distance = Math.sqrt(
                    Math.pow(pointer.x - firstPoint.x, 2) +
                    Math.pow(pointer.y - firstPoint.y, 2)
                );

                if (distance < 10) {
                    finishPolygon();
                    return;
                }
            }

            polygonPoints.push({ x: pointer.x, y: pointer.y });
            updatePolygonPreview();
        }

        function updatePolygonPreview() {
            if (polygonLineGroup) {
                canvas.remove(polygonLineGroup);
            }

            if (polygonPoints.length === 0) return;

            const lines = [];
            for (let i = 0; i < polygonPoints.length - 1; i++) {
                lines.push(new fabric.Line([
                    polygonPoints[i].x, polygonPoints[i].y,
                    polygonPoints[i + 1].x, polygonPoints[i + 1].y
                ], {
                    stroke: 'white',
                    strokeWidth: 2,
                    selectable: false,
                    evented: false
                }));
            }

            polygonPoints.forEach(point => {
                lines.push(new fabric.Circle({
                    left: point.x - 3,
                    top: point.y - 3,
                    radius: 3,
                    fill: 'white',
                    stroke: 'black',
                    strokeWidth: 1,
                    selectable: false,
                    evented: false
                }));
            });

            polygonLineGroup = new fabric.Group(lines, {
                selectable: false,
                evented: false
            });

            canvas.add(polygonLineGroup);
            canvas.renderAll();
        }

        function finishPolygon() {
            if (polygonPoints.length < 3) return;

            console.log('>>> Finishing polygon with', polygonPoints.length, 'points');

            if (polygonLineGroup) {
                canvas.remove(polygonLineGroup);
                polygonLineGroup = null;
            }

            const polygon = new fabric.Polygon(polygonPoints, {
                fill: 'rgba(0, 100, 255, 0.8)',
                stroke: 'rgb(0, 100, 255)',
                strokeWidth: 1,
                selectable: true,
                evented: true,
                opacity: maskOpacity
            });

            console.log('Polygon created:', {
                type: polygon.type,
                selectable: polygon.selectable,
                evented: polygon.evented
            });

            canvas.add(polygon);
            console.log('Polygon added. Total objects:', canvas.getObjects().length);
            canvas.renderAll();

            polygonPoints = [];
            isDrawingPolygon = false;

            setTool(tools.SELECT);
        }

        function clearPolygon() {
            if (polygonLineGroup) {
                canvas.remove(polygonLineGroup);
                polygonLineGroup = null;
            }
            polygonPoints = [];
            isDrawingPolygon = false;
            canvas.renderAll();
        }

        canvas.on('mouse:dblclick', function () {
            if (currentTool === tools.POLYGON) {
                finishPolygon();
            }
        });

        /* ------------------------------
           UNDO / REDO
        ------------------------------ */
        function saveState() {
            const json = JSON.stringify(canvas.toJSON(['selectable', 'evented', 'globalCompositeOperation']));
            historyStack.push(json);

            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift();
            }

            redoStack = [];
        }

        function undo() {
            if (historyStack.length === 0) return;

            const currentState = JSON.stringify(canvas.toJSON(['selectable', 'evented', 'globalCompositeOperation']));
            redoStack.push(currentState);

            const previousState = historyStack.pop();
            canvas.loadFromJSON(previousState, function () {
                canvas.renderAll();
                setTool(currentTool);
            });
        }

        function redo() {
            if (redoStack.length === 0) return;

            const currentState = JSON.stringify(canvas.toJSON(['selectable', 'evented', 'globalCompositeOperation']));
            historyStack.push(currentState);

            const nextState = redoStack.pop();
            canvas.loadFromJSON(nextState, function () {
                canvas.renderAll();
                setTool(currentTool);
            });
        }

        canvas.on('path:created', function (e) {
            if (currentTool === tools.ERASER) {
                e.path.globalCompositeOperation = 'destination-out';
                e.path.selectable = false;
                e.path.evented = false;
            } else {
                e.path.selectable = true;
                e.path.evented = true;
            }
            saveState();
        });

        /* ------------------------------
           DELETE SELECTED
        ------------------------------ */
        function deleteSelected() {
            const activeObjects = canvas.getActiveObjects();
            console.log('>>> DELETE called. Active objects:', activeObjects.length);

            if (activeObjects.length === 0) {
                console.log('No objects selected to delete');
                return;
            }

            console.log('Deleting objects:', activeObjects.map(obj => obj.type));
            saveState();

            activeObjects.forEach(obj => {
                canvas.remove(obj);
            });

            canvas.discardActiveObject();
            canvas.renderAll();
            console.log('Objects deleted. Remaining:', canvas.getObjects().length);
        }

        /* ------------------------------
           API CALLS
        ------------------------------ */
        function getMetadata() {
            const canvasJSON = canvas.toJSON(['selectable', 'evented', 'globalCompositeOperation']);
            return {
                meta: { original_width: originalWidth, original_height: originalHeight, timestamp: new Date().toISOString() },
                fabricJSON: canvasJSON,
                shapes: convertFabricToShapes(canvasJSON)
            };
        }

        function convertFabricToShapes(fabricJSON) {
            const shapes = [];

            fabricJSON.objects.forEach(obj => {
                if (obj.type === 'image') return;

                const shape = {
                    type: obj.type,
                    left: obj.left || 0,
                    top: obj.top || 0,
                    width: obj.width || 0,
                    height: obj.height || 0,
                    fill: obj.fill,
                    stroke: obj.stroke,
                    strokeWidth: obj.strokeWidth || 0
                };

                if (obj.type === 'rect') {
                    shape.points = [
                        { x: obj.left, y: obj.top },
                        { x: obj.left + obj.width, y: obj.top },
                        { x: obj.left + obj.width, y: obj.top + obj.height },
                        { x: obj.left, y: obj.top + obj.height }
                    ];
                } else if (obj.type === 'ellipse') {
                    shape.radiusX = obj.rx;
                    shape.radiusY = obj.ry;
                    shape.center = { x: obj.left + obj.rx, y: obj.top + obj.ry };
                } else if (obj.type === 'polygon') {
                    shape.points = obj.points;
                } else if (obj.type === 'path') {
                    shape.path = obj.path;
                }

                shapes.push(shape);
            });

            return shapes;
        }

        function saveMask(isSubmitting = false) {
            const originalOpacities = [];
            const originalVisibilities = [];
            const originalBackgroundColor = canvas.backgroundColor;

            canvas.backgroundColor = 'transparent';

            canvas.getObjects().forEach((obj, index) => {
                if (obj.type === 'image') {
                    originalVisibilities[index] = obj.visible;
                    obj.set('visible', false);
                } else {
                    originalOpacities[index] = obj.opacity;
                }
            });
            canvas.renderAll();

            const dataUrl = canvas.toDataURL({
                format: 'png',
                quality: 1.0,
                multiplier: 1,
                enableRetinaScaling: false
            });

            canvas.backgroundColor = originalBackgroundColor;
            canvas.getObjects().forEach((obj, index) => {
                if (obj.type === 'image') {
                    obj.set('visible', originalVisibilities[index]);
                } else {
                    obj.set('opacity', originalOpacities[index]);
                }
            });
            canvas.renderAll();

            const metadata = getMetadata();

            return fetch(`/api/segmenter/task/${taskId}/save-mask/`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "X-CSRFToken": getCSRFToken()
                },
                body: JSON.stringify({
                    mask: dataUrl,
                    metadata: metadata
                })
            })
                .then(res => res.json())
                .then(data => {
                    if (!isSubmitting) alert("Draft Saved!");
                })
                .catch(err => {
                    console.error("Save error:", err);
                    alert("Error saving mask!");
                });
        }

        function submitTask() {
            if (!confirm("Finish task?")) return;

            saveMask(true).then(() => {
                fetch(`/api/segmenter/task/${taskId}/submit/`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "X-CSRFToken": getCSRFToken()
                    }
                })
                    .then(() => {
                        alert("Submitted!");
                        window.location.href = "/segmenter/my-tasks/";
                    })
                    .catch(err => {
                        console.error("Submit error:", err);
                        alert("Error submitting task!");
                    });
            });
        }

        function getCSRFToken() {
            return document.cookie.split("; ").find(row => row.startsWith("csrftoken"))?.split("=")[1];
        }

        /* ------------------------------
           KEYBOARD SHORTCUTS
        ------------------------------ */
        document.addEventListener("keydown", e => {
            if (e.target.tagName === "INPUT") return;

            if (e.key === "v") setTool(tools.SELECT);
            else if (e.key === "b") setTool(tools.BRUSH);
            else if (e.key === "e") setTool(tools.ERASER);
            else if (e.key === "p") setTool(tools.PENCIL);
            else if (e.key === "r") setTool(tools.RECT);
            else if (e.key === "c") setTool(tools.CIRCLE);
            else if (e.key === "g") setTool(tools.POLYGON);
            else if (e.key === "Delete" || e.key === "Backspace") deleteSelected();
            else if (e.key === "z" && !e.ctrlKey) undo();
            else if (e.key === "y" && !e.ctrlKey) redo();
            else if (e.key === "s" && !e.ctrlKey) {
                e.preventDefault();
                saveMask();
            }
            else if (e.key === "Enter" && currentTool === tools.POLYGON) {
                finishPolygon();
            }
        });

        /* ------------------------------
           INITIALIZATION
        ------------------------------ */
        fetch(`/api/segmenter/task/${taskId}/`)
            .then(res => {
                if (!res.ok) {
                    throw new Error(`HTTP error! status: ${res.status}`);
                }
                return res.json();
            })
            .then(task => {
                console.log("Task data received:", task);

                if (!task.image_path) {
                    console.error("Task data missing image_path:", task);
                    alert("Error: Image path not found in task data!");
                    return;
                }

                document.getElementById("taskId").innerText = task.task_id;
                document.getElementById("imageName").innerText = task.image_name;

                const img = new Image();
                img.crossOrigin = "anonymous";

                img.onerror = function () {
                    console.error("Failed to load image:", task.image_path);
                    alert(`Failed to load image: ${task.image_path}\nPlease check if the file exists and is accessible.`);
                };

                img.src = task.image_path;
                console.log("Loading image from:", task.image_path);

                img.onload = () => {
                    console.log("Image loaded successfully:", img.width, "x", img.height);
                    originalWidth = img.width;
                    originalHeight = img.height;

                    imageCanvas.width = originalWidth;
                    imageCanvas.height = originalHeight;
                    imgCtx.drawImage(img, 0, 0);

                    canvas.setWidth(originalWidth);
                    canvas.setHeight(originalHeight);

                    const fabricCanvasEl = canvas.wrapperEl;
                    if (fabricCanvasEl) {
                        fabricCanvasEl.style.position = 'absolute';
                        fabricCanvasEl.style.left = '0';
                        fabricCanvasEl.style.top = '0';
                    }

                    applyZoom(1.0);

                    setTool(tools.BRUSH);

                    // Load AI mask if available
                    loadAIMask();
                };

                if (task.status === 'REJECTED' && task.feedback) {
                    const msg = `‚ö†Ô∏è REJECTED: ${task.feedback}`;
                    alert(msg);

                    const div = document.createElement("div");
                    div.style = "background: #ffebee; color: #c62828; padding: 10px; margin-bottom: 10px; border: 1px solid #ef9a9a; border-radius: 4px;";
                    div.innerText = msg;
                    document.querySelector(".toolbar").prepend(div);
                }
            })
            .catch(err => {
                console.error("Error loading task:", err);
                alert(`Error loading task: ${err.message}\n\nPlease check:\n1. Are you logged in?\n2. Does task ID ${taskId} exist?\n3. Check browser console for details.`);
            });

        function loadAIMask() {
            fetch(`/api/ai/presegment/${taskId}/`)
                .then(res => res.json())
                .then(data => {
                    if (!data.mask) return;

                    fabric.Image.fromURL(data.mask, function (img) {
                        img.set({
                            left: 0,
                            top: 0,
                            selectable: false,
                            opacity: maskOpacity
                        });
                        canvas.add(img);
                        canvas.sendToBack(img);
                        canvas.renderAll();

                        saveState();
                    });
                })
                .catch(err => {
                    console.error("Error loading AI mask:", err);
                });
        }
    </script>
</body>

</html>