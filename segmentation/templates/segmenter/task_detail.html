<!DOCTYPE html>
<html>

<head>
    <title>Segmentation Task</title>
    <meta charset="UTF-8" />

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            /* Prevent full page scroll when drawing */
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Toolbar Styling */
        .toolbar {
            margin-bottom: 10px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            flex-shrink: 0;
            /* Don't shrink toolbar */
        }

        .tool-group {
            display: inline-block;
            margin-right: 20px;
            border-right: 1px solid #ccc;
            padding-right: 20px;
        }

        /* 
           CONTAINER FOR ZOOMING 
           This box stays the same size on screen, but handles scrollbars 
        */
        #canvasContainer {
            flex-grow: 1;
            /* Fill remaining height */
            overflow: auto;
            /* Show scrollbars if zoomed */
            border: 2px solid #999;
            background-color: #333;
            /* Dark background for easier viewing */
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* The wrapper that actually gets resized by CSS */
        #canvasWrapper {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        canvas {
            display: block;
            /* Important: Width/Height controlled by JS for Zoom */
        }
    </style>
</head>

<body>

    <div class="toolbar">
        <!-- TOOLS -->
        <div class="tool-group">
            <button onclick="setTool('brush')">üñå Brush (B)</button>
            <button onclick="setTool('eraser')">üßΩ Eraser (E)</button>
            <button onclick="setTool('pencil')">‚úèÔ∏è Pencil (P)</button>
            <button onclick="setTool('rect')">‚¨õ Rect (R)</button>
            <button onclick="setTool('circle')">‚ö™ Circle (C)</button>
            <button onclick="setTool('polygon')">üî∫ Polygon (G)</button>
        </div>

        <!-- ACTIONS -->
        <div class="tool-group">
            <button onclick="undo()">‚Ü© Undo (Z)</button>
            <button onclick="redo()">‚Ü™ Redo (Y)</button>
            <button onclick="saveMask()">üíæ Save (S)</button>

            <button onclick="submitTask()" style="background-color: #4CAF50; color: white;">‚úÖ Submit Task</button>
        </div>

        <!-- ZOOM & OPACITY -->
        <div class="tool-group">
            <strong>Zoom:</strong>
            <button onclick="changeZoom(0.1)">‚ûï</button>
            <button onclick="changeZoom(-0.1)">‚ûñ</button>
            <button onclick="resetZoom()">Fit</button>
            <span id="zoomDisplay">100%</span>
        </div>

        <div>
            Opacity: <input type="range" min="0.0" max="1.0" step="0.1" value="0.5" oninput="setMaskOpacity(this.value)"
                style="vertical-align: middle;">
            &nbsp;|&nbsp;
            Brush: <input type="range" min="1" max="50" value="10" oninput="brushSize=this.value"
                style="vertical-align: middle;">
        </div>

        <div style="margin-top:5px; font-size: 0.85em; color: #666;">
            Task: <span id="taskId">...</span> | Image: <span id="imageName">...</span>
        </div>
    </div>

    <!-- MAIN WORKSPACE -->
    <div id="canvasContainer">
        <div id="canvasWrapper">
            <canvas id="imageCanvas"></canvas>
            <canvas id="maskCanvas" style="position:absolute; left:0; top:0; opacity: 0.5;"></canvas>
        </div>
    </div>

    <script>
        /* ------------------------------
           BASIC SETUP
        ------------------------------ */
        const parts = window.location.pathname.split("/").filter(Boolean);
        const taskId = parts[parts.length - 1];

        const canvasWrapper = document.getElementById("canvasWrapper");
        const imageCanvas = document.getElementById("imageCanvas");
        const maskCanvas = document.getElementById("maskCanvas");

        const imgCtx = imageCanvas.getContext("2d");
        const maskCtx = maskCanvas.getContext("2d", { willReadFrequently: true });

        // Set drawing color
        maskCtx.fillStyle = "rgb(0, 100, 255)";
        maskCtx.strokeStyle = "rgb(0, 100, 255)";

        /* ------------------------------
           DATA STORAGE (JSON)
        ------------------------------ */
        let storedShapes = []; // Stores all vector data
        let currentPath = [];  // Temporarily holds points for Brush/Pencil

        /* ------------------------------
           ZOOM STATE
        ------------------------------ */
        let currentZoom = 1.0;
        let originalWidth = 0;
        let originalHeight = 0;

        /* ------------------------------
           TOOL STATE
        ------------------------------ */
        const tools = { BRUSH: "brush", ERASER: "eraser", PENCIL: "pencil", RECT: "rect", CIRCLE: "circle", POLYGON: "polygon" };
        let currentTool = tools.BRUSH;
        let brushSize = 10;
        let isDrawing = false;
        let startX = 0, startY = 0;
        let polygonPoints = [];
        let polygonPreviewImage = null;
        let isShiftPressed = false;
        const SNAP_DISTANCE = 10;

        /* ------------------------------
           ZOOM FUNCTIONS
        ------------------------------ */
        function changeZoom(delta) {
            const newZoom = Math.max(0.1, Math.min(5.0, currentZoom + delta));
            applyZoom(newZoom);
        }
        function resetZoom() { applyZoom(1.0); }

        function applyZoom(zoomLevel) {
            currentZoom = zoomLevel;
            document.getElementById("zoomDisplay").innerText = Math.round(currentZoom * 100) + "%";
            const cssWidth = originalWidth * currentZoom;
            const cssHeight = originalHeight * currentZoom;
            imageCanvas.style.width = cssWidth + "px";
            imageCanvas.style.height = cssHeight + "px";
            maskCanvas.style.width = cssWidth + "px";
            maskCanvas.style.height = cssHeight + "px";
            canvasWrapper.style.width = cssWidth + "px";
            canvasWrapper.style.height = cssHeight + "px";
        }

        /* ------------------------------
           COORDINATE HELPER
        ------------------------------ */
        function getMousePos(e) {
            const rect = maskCanvas.getBoundingClientRect();
            const scaleX = maskCanvas.width / rect.width;
            const scaleY = maskCanvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        /* ------------------------------
           MOUSE EVENTS
        ------------------------------ */
        maskCanvas.addEventListener("mousedown", e => {
            const pos = getMousePos(e);
            startX = pos.x;
            startY = pos.y;

            if (currentTool === tools.POLYGON) {
                handlePolygonClick(startX, startY);
                return;
            }

            isDrawing = true;
            saveState(); // Save pixel state for Undo

            // For Brush/Pencil/Eraser, start recording path
            if ([tools.BRUSH, tools.PENCIL, tools.ERASER].includes(currentTool)) {
                currentPath = [{ x: startX, y: startY }];
            }
        });

        maskCanvas.addEventListener("mousemove", e => {
            const pos = getMousePos(e);
            const mouseX = pos.x;
            const mouseY = pos.y;

            if (currentTool === tools.POLYGON && polygonPoints.length > 0) {
                drawPolygonPreview(mouseX, mouseY);
                return;
            }

            if (!isDrawing) return;

            // Draw Pixels
            if (currentTool === tools.BRUSH) drawBrush(mouseX, mouseY);
            else if (currentTool === tools.ERASER) erase(mouseX, mouseY);
            else if (currentTool === tools.PENCIL) drawPixel(mouseX, mouseY);

            // Record Coordinates for Brush/Pencil/Eraser
            if ([tools.BRUSH, tools.PENCIL, tools.ERASER].includes(currentTool)) {
                currentPath.push({ x: mouseX, y: mouseY });
            }
        });

        maskCanvas.addEventListener("mouseup", e => {
            if (!isDrawing) return;
            isDrawing = false;
            const pos = getMousePos(e);
            const endX = pos.x;
            const endY = pos.y;

            // 1. Draw Shapes & Store Data
            if (currentTool === tools.RECT) {
                drawRect(startX, startY, endX, endY);

                // Store Rectangle JSON
                const w = Math.abs(endX - startX);
                const h = Math.abs(endY - startY);
                const left = Math.min(startX, endX);
                const top = Math.min(startY, endY);

                recordShape("rectangle", {
                    left: left, top: top, width: w, height: h,
                    points: [{ x: left, y: top }, { x: left + w, y: top }, { x: left + w, y: top + h }, { x: left, y: top + h }]
                });
            }
            else if (currentTool === tools.CIRCLE) {
                drawCircle(startX, startY, endX, endY);

                // Store Circle JSON
                const rx = Math.abs(endX - startX) / 2;
                const ry = Math.abs(endY - startY) / 2;
                const cx = (startX + endX) / 2;
                const cy = (startY + endY) / 2;

                recordShape("circle", {
                    left: cx - rx, top: cy - ry, width: rx * 2, height: ry * 2,
                    radiusX: rx, radiusY: ry,
                    center: { x: cx, y: cy }
                });
            }
            else if ([tools.BRUSH, tools.PENCIL, tools.ERASER].includes(currentTool)) {
                // Store Path JSON
                // We calculate a bounding box for the path just in case you need it
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                currentPath.forEach(p => {
                    if (p.x < minX) minX = p.x;
                    if (p.x > maxX) maxX = p.x;
                    if (p.y < minY) minY = p.y;
                    if (p.y > maxY) maxY = p.y;
                });

                recordShape(currentTool, { // type will be 'brush', 'pencil' or 'eraser'
                    points: [...currentPath], // Copy array
                    strokeWidth: (currentTool === tools.PENCIL) ? 1 : brushSize,
                    left: minX, top: minY, width: maxX - minX, height: maxY - minY
                });
                currentPath = [];
            }
        });

        /* ------------------------------
           DATA RECORDING HELPER
        ------------------------------ */
        function recordShape(type, data) {
            const shape = {
                type: type,
                left: data.left || 0,
                top: data.top || 0,
                width: data.width || 0,
                height: data.height || 0,
                fill: (type === 'eraser') ? null : "#0064ff80",
                stroke: (type === 'eraser') ? null : "#0064ff",
                strokeWidth: data.strokeWidth || 0,
                points: data.points || [], // Array of {x,y}
                // Add specific props
                ...data
            };

            // Remove 'points' from spread if it duplicates, but JS handles it.
            storedShapes.push(shape);
            console.log("Recorded:", shape);
        }

        /* ------------------------------
           DRAWING FUNCTIONS (PIXELS)
        ------------------------------ */
        function drawBrush(x, y) {
            maskCtx.beginPath();
            maskCtx.arc(x, y, brushSize, 0, Math.PI * 2);
            maskCtx.fill();
        }
        function erase(x, y) {
            maskCtx.globalCompositeOperation = "destination-out";
            maskCtx.beginPath();
            maskCtx.arc(x, y, brushSize, 0, Math.PI * 2);
            maskCtx.fill();
            maskCtx.globalCompositeOperation = "source-over";
        }
        function drawPixel(x, y) { maskCtx.fillRect(Math.floor(x), Math.floor(y), 1, 1); }
        function drawRect(x1, y1, x2, y2) {
            maskCtx.fillRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));
        }
        function drawCircle(x1, y1, x2, y2) {
            const cx = (x1 + x2) / 2; const cy = (y1 + y2) / 2;
            const rx = Math.abs(x2 - x1) / 2; const ry = Math.abs(y2 - y1) / 2;
            maskCtx.beginPath(); maskCtx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2); maskCtx.fill();
        }

        /* ------------------------------
           POLYGON LOGIC
        ------------------------------ */
        function handlePolygonClick(px, py) {
            if (polygonPoints.length === 0) {
                saveState();
                polygonPreviewImage = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
            }
            if (polygonPoints.length > 0) {
                const first = polygonPoints[0];
                if (Math.hypot(px - first.x, py - first.y) < SNAP_DISTANCE && polygonPoints.length >= 3) {
                    px = first.x; py = first.y;
                }
            }
            polygonPoints.push({ x: px, y: py });
        }

        function drawPolygonPreview(currX, currY) {
            maskCtx.putImageData(polygonPreviewImage, 0, 0);
            const first = polygonPoints[0];
            const last = polygonPoints[polygonPoints.length - 1];
            if (isShiftPressed) {
                if (Math.abs(currX - last.x) > Math.abs(currY - last.y)) currY = last.y;
                else currX = last.x;
            }
            maskCtx.beginPath();
            maskCtx.moveTo(first.x, first.y);
            polygonPoints.forEach(p => maskCtx.lineTo(p.x, p.y));
            maskCtx.lineTo(currX, currY);
            maskCtx.lineWidth = 2; maskCtx.strokeStyle = "rgba(0,0,0,0.8)"; maskCtx.stroke();
            maskCtx.strokeStyle = "white"; maskCtx.lineWidth = 1; maskCtx.stroke();
            maskCtx.lineWidth = 1; maskCtx.fillStyle = "rgb(0, 100, 255)";
        }

        maskCanvas.addEventListener("dblclick", () => finishPolygon());
        document.addEventListener("keydown", e => { if (e.key === "Enter" && currentTool === tools.POLYGON) finishPolygon(); });

        function finishPolygon() {
            if (polygonPoints.length < 3) return;
            maskCtx.putImageData(polygonPreviewImage, 0, 0);
            maskCtx.beginPath();
            maskCtx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
            polygonPoints.forEach(p => maskCtx.lineTo(p.x, p.y));
            maskCtx.closePath();
            maskCtx.fill();

            // STORE POLYGON JSON
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            polygonPoints.forEach(p => {
                if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y;
            });

            recordShape("polygon", {
                left: minX, top: minY, width: maxX - minX, height: maxY - minY,
                points: [...polygonPoints]
            });

            polygonPoints = [];
            polygonPreviewImage = null;
        }

        /* ------------------------------
           UNDO / REDO / SAVE
        ------------------------------ */
        const undoStack = []; const redoStack = [];

        function saveState() {
            undoStack.push(maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height));
            if (undoStack.length > 30) undoStack.shift();
            redoStack.length = 0;
        }

        function undo() {
            if (!undoStack.length) return;
            redoStack.push(maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height));
            maskCtx.putImageData(undoStack.pop(), 0, 0);
            // Undo the JSON data too
            if (storedShapes.length > 0) storedShapes.pop();
        }

        function redo() {
            if (!redoStack.length) return;
            undoStack.push(maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height));
            maskCtx.putImageData(redoStack.pop(), 0, 0);
            // Note: Redoing JSON is hard without a separate stack. 
            // For simplicity, we only sync pixel redo here.
        }

        /* ------------------------------
           API CALLS
        ------------------------------ */
        function getMetadata() {
            return {
                meta: {
                    original_width: imageCanvas.width,
                    original_height: imageCanvas.height,
                    timestamp: new Date().toISOString()
                },
                shapes: storedShapes // <--- SEND ALL SHAPES
            };
        }

        function saveMask(isSubmitting = false) {
            const oldOpacity = maskCanvas.style.opacity;
            maskCanvas.style.opacity = "1.0";
            const dataUrl = maskCanvas.toDataURL("image/png");
            maskCanvas.style.opacity = oldOpacity;

            const metadata = getMetadata();

            return fetch(`/api/segmenter/task/${taskId}/save-mask/`, {
                method: "POST",
                headers: { "Content-Type": "application/json", "X-CSRFToken": getCSRFToken() },
                body: JSON.stringify({ mask: dataUrl, metadata: metadata })
            })
                .then(res => res.json())
                .then(data => {
                    if (!isSubmitting) alert("Draft Saved!");
                });
        }

        function submitTask() {
            if (!confirm("Finish task?")) return;
            saveMask(true).then(() => {
                fetch(`/api/segmenter/task/${taskId}/submit/`, {
                    method: "POST", headers: { "Content-Type": "application/json", "X-CSRFToken": getCSRFToken() }
                }).then(() => {
                    alert("Submitted!");
                    window.location.href = "/segmenter/my-tasks/";
                });
            });
        }

        function getCSRFToken() {
            return document.cookie.split("; ").find(row => row.startsWith("csrftoken"))?.split("=")[1];
        }

        /* ------------------------------
           INIT & UTILS
        ------------------------------ */
        function setTool(t) { currentTool = t; polygonPoints = []; }
        function setMaskOpacity(val) { maskCanvas.style.opacity = val; }

        document.addEventListener("keydown", e => {
            if (e.target.tagName === "INPUT") return;
            if (e.key === "b") setTool(tools.BRUSH);
            if (e.key === "e") setTool(tools.ERASER);
            if (e.key === "z") undo();
            if (e.key === "Shift") isShiftPressed = true;
        });
        document.addEventListener("keyup", e => { if (e.key === "Shift") isShiftPressed = false; });

        fetch(`/api/segmenter/task/${taskId}/`)
            .then(res => res.json())
            .then(task => {
                document.getElementById("taskId").innerText = task.task_id;
                document.getElementById("imageName").innerText = task.image_name;
                const img = new Image();
                img.src = task.image_path;
                img.onload = () => {
                    originalWidth = img.width;
                    originalHeight = img.height;
                    imageCanvas.width = originalWidth; imageCanvas.height = originalHeight;
                    maskCanvas.width = originalWidth; maskCanvas.height = originalHeight;
                    imgCtx.drawImage(img, 0, 0);
                    applyZoom(1.0);
                    loadAIMask();
                };
                if (task.status === 'REJECTED' && task.feedback) {
                    const msg = `‚ö†Ô∏è REJECTED: ${task.feedback}`;
                    alert(msg); // Or display it in a red box on the UI

                    // Optional: Create a visual div
                    const div = document.createElement("div");
                    div.style = "background: #ffebee; color: #c62828; padding: 10px; margin-bottom: 10px; border: 1px solid #ef9a9a; border-radius: 4px;";
                    div.innerText = msg;
                    document.querySelector(".toolbar").prepend(div);
                }

            });

        function loadAIMask() {
            fetch(`/api/ai/presegment/${taskId}/`)
                .then(res => res.json())
                .then(data => {
                    if (!data.mask) return;
                    const m = new Image();
                    m.src = data.mask;
                    m.onload = () => maskCtx.drawImage(m, 0, 0);
                });
        }
    </script>
</body>

</html>